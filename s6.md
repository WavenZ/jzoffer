## 面试题6：从尾到头打印链表

> 题目：输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下：

```cpp
struct ListNode
{
    int         m_nKey;
    ListNode*   m_pNext;
};
```

通常打印时一个只读操作，我们不希望打印时修改内容。假设面试官也要求这个
题目不能改变链表的结构。

接下来我们想到解决这个问题肯定要遍历链表。遍历的顺序时从头到尾，可输出的顺序却是从尾到头。也就是说，第一个遍历到的节点最后一个输出，而最后一个遍历到的节点第一个输出。这就是典型的“后进先出”，我们可以用栈实现这个顺序。每经过一个节点的时候，把该节点放到一个栈中。当遍历完整个链表后，
再从栈顶开始逐个输出节点的值，此时输出的节点的顺序已经反转过来了。这种
    
思路的实现代码如下：
```cpp
void Traverse_reversely1(ListNode* Head){
    stack<int> keys;
    ListNode* p = Head;
    while(p){
        keys.push(p->m_nKey);
        p = p->m_pNext;
    }
    while(!keys.empty()){
        int key = keys.top();
        keys.pop();
    }
}
```
既然想到了用栈来实现这个函数，而递归在本质上就是一个栈结构，于是很自然地又想到了递归来实现。要实现反过来输出链表，我们每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身，这样链表的输出结构就反过来了。

基于这样的思路，不难写出如下代码：

```cpp
void Traverse_reversely2(ListNode* Head) {
    if (Head == nullptr) return;
    Traverse_reversely2(Head->m_pNext);
    cout << Head->m_nKey << " ";
}
```

上面的基于递归的代码看起来很简洁，但有一个问题：当链表非常长的时候，就会导致函数调用的层继很深，从而有可能导致函数调用栈溢出。显然用栈计语循环实现的代码的鲁棒性要好一些。


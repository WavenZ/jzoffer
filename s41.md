## 面试题41：数据流中的中位数

> 题目：如何得到一个数据里中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

由于数据是从一个数据流中读出来的，因而数据的数目随着时间的变化而增加。如果用一个数据容器来保存从流中读出来的数据，则当有新的数据从流中读出来时，这些容器就插入数据容器。

数组是最简单的数据容器。如果数组没有排序，则可以用 Partition 函数找出数组中的中位数。在没有排序的数组中插入一个数字和找出中位数的时间复杂度分别是 O(1) 和 O(n)。

我们还可以在往数组里插入新数据时让数组保持排序。这时由于可能需要移动 O(n) 个数，因此需要 O(n) 时间才能完成插入操作。在已经排好序的数组中找出中位数是一个简单的操作，只需要 O(1) 时间即可完成。

排序的链表是另外一种选择。我们需要 O(n) 时间才能在链表中找到合适的位置插入新的数据。如果定义两个指针指向同一个节点（如果链表的节点数目是奇数，那么这两个指针指向同一个节点），那么可以在 O(1) 时间内得出中位数。此时的时间复杂度与基于排序的数组的时间复杂度一样。

二叉搜索树可以把插入新数据的平均时间降低到 O(logn)。但是当二叉树极度不平衡从而看起来像一个排序的链表时，插入新数据的时间仍然是 O(n)。为了得到中位数，可以在二叉树节点中添加一个表示子树节点数目的字段。有了这个字段，可以在平均 O(logn) 时间内得到中位数，但最差情况仍然需要 O(n) 时间。

为了避免二叉搜索树的最差情况，还可以利用平衡的二叉搜索树，即 AVL 树。通常 AVL 树的平衡因此是左右子树的高度差。可以稍作修改，把 AVL 的平衡因此改为左右子树节点数目之差。有了这个改动，可以用 O(logn) 时间往 AVL 树中添加一个新节点，同时用 O(1) 时间得到所有节点的中位数。AVL 树的时间效率很高，但大部分编程语言的函数库中都没有实现这个数据结构。通常很难在短时间内实现 AVL 树的插入操作。

值得注意的是，整个数据容器可以被分隔成两部分。位于容器左边部分的数据比右边的数据小。另外，P1 指向的数据是左边部分最大的数，P2 指向的数据是左边部分最小的数。

如果能够保证数据容器左边的数据都小于右边的数据，那么即使左右两边内部的数据没有排序，也可以根据左边最大的数及右边最小的数得到中位数。如何快速从一个数据容器中找出最大数？用最大堆实现这个数据容器，因为位于堆顶的就是最大的数据。同样，也可以快速从最小堆中找出最小数。

因此，可以用如下思路来解决这个问题：用一个最大堆实现左边的数据容器，用一个最小堆实现右边的数据容器。往堆中插入一个数据的时间效率是 O(logn)。由于只需要 O(1) 时间就可以得到位于堆顶的数据，因此得到中位数的时间复杂度是 O(1)。

接下来考虑用最大堆和最小堆实现的一些细节。首先要保证数据平均分配到两个堆中，因此两个堆中数据的数目之差不能超过 1。为了实现平均分配，可以在数据的总数目是偶数时把新数据插入最小堆，否则插入最大堆。

还要保证最大堆中的所有数据都要小于最小堆中的数据。当数据的总数目是偶数时，按照前面的分配规则会把新的数据插入最小堆。如果此时这个新数据比最大堆中的一些数据要小，那该怎么办？

可以先把这个新数据插入最大堆，接着把最大堆中最大的数字拿出来插入最小堆。由于最终插入最小堆的数字是原最大堆中最大的数字，这样就保证了最小堆中所有数字都大于最大堆中的数字。

```cpp
template<typename T>
class DynamicArray{
public:
    void Insert(T num){
        if(((min.size() + max.size()) & 1) == 0){
            if(max.size() > 0 && num < max[0]){
                max.push_back(num);
                push_heap(max.begin(), max.end(), less<T>())

                num = max[0];

                pop_heap(max.begin(), max.end(), less<T>());
                max.pop_back();
            }
            min.push_back(num);
            push_heap(min.begin(), min.end(), greater<T>());
        }
        else{
            if(min.size() > 0 && min[0] < num){
                min.push_back(num);
                push_heap(min.begin(), min.end(), greater<T>())

                num = min[0];

                pop_heap(min.begin(), min.end(), greater<T>());
                min.pop_back();
            }
            max.push_back(num);
            push_heap(max.begin(), max.end(), less<T>());
        }
    }
    T GetMedian(){
        int size = min.size() + max.size();
        if(size == 0)
            throw "No numbers are available";
        T median = 0;
        if((size & 1) == 1)
            median = min[0];
        else
            median = (min[0] + max[0]) / 2;
        return median;
    }
private:
    vector<T> min;
    vector<T> max;
}
```

## 面试题15：二进制中1的个数

> 题目：请实现一个函数，输入一个整数，输出该二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

### 可能引起死循环的解法

这是一道很基本的考查二进制和位运算的面试题。题目不是很难，面试官提出问题之后，我们很快就能形成一个基本的思路：先判断整数二进制表示中最右边一位是不是 1；接着把输入的整数右移一位，此时原来处于从右边数起的第二位被移到最右边了，再判断是不是 1；这样每次移动一位，直到整个整数变成 0 为止。现在的问题变成了怎么判断一个整数的最右边是不是 1。这很简单，只要把整数和 1 做位与运算是不是 0 就知道了。1 除最右边的一位之外所有位都是 0。如果一个整数与 1 做与运算的结果是 1，则表示该整数最右边一位是 1，否则是 0。基于这种思路，我们很快就能写出如下代码：
```cpp
int NumberOf1(int n){
    int count = 0;
    while(n){
        if(n & 1) count ++;
        n = n >> 1;
    }
    return count;
}
```
面试官看了代码之后可能会问：把整数右移一位和把整数除以 2 在数学上是等价的，那上面的代码中可以把右移运算换成除以 2 吗？答案是否定的。因为除法的效率比移位运算要低得多，在实际编程中应尽可能地用移位运算符代替乘除法。

面试官接下来可能要问的第二个问题就是：上面的函数如果输入一个负数，比如0x80000000，则运行的时候会发生什么情况？当把负数 0x80000000 右移一位的时候，并不是简单地把最高位的1移到第二位变成 0x40000000，而是 0xC0000000。**这是因为移位前是一个负数，仍然要保证移位后是一个负数**，因此移位后的最高位会设为 1。如果一直做右移运算，那么最终这个数字就会变成 0xFFFFFFFF 而陷入死循环。

### 常规解法

为了避免死循环，我们可以不右移输入的数字 n。首先把 n 和 1 做与运算，判断 n 的最低位是不是为 1。接着把 1 左移一位得到 2，再和 n 做与运算，就能判断 n 的次低位是不是 1 ······ 这样反复左移，每次都能判断 n 的其中一位是不是 1。基于这种思路，我们可以把代码修改如下：
```cpp
int NumberOf1(int n){
    int count = 0;
    unsigned int flag = 1;
    while(flag){
        if(n & flag) count ++;
        flag = flag << 1;
    }
    return count;
}
```

### 能给面试官带来惊喜的解法

把一个整数减去1，再和原整数做与运算，会把该整数最右边的 1 变成 0。那么一个整数的二进制表示中有多少个 1，就可以进行多少次这样的操作。

```cpp
int NumberOf1(int n){
    int count = 0;

    while(n){
        ++count;
        n = (n - 1) & n;
    }
    return count;
}
```
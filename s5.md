## 面试题5：替换空格
> 题目：请实现一个函数，把字符串中的而每个空格替换成“%20”。例如，输入“We are happy.”，则输出 “We%20are%happy.”

**时间复杂度为O(n²)的解法**

最直观的做法时从头到尾扫描字符串，每次碰到空格字符的是偶进行替换。由于是把 1 个字符替换成 3 个字符，我们必须要把空格后面的字符都后移 2 字节，否则就有两个字符被覆盖了。

当我们把这种思路阐述给面试官后，他不会就此满意，他将让我们寻找更快
的方法。在前面的分析中，我们发现数组中很多字符都移动了很多次，能不能
减少移动次数呢？答案是肯定的。我们换一种思路，把从前向后替换改成从后
向前替换。

**时间复杂度为O(n)的解法**

我们可以先遍历一次字符串，这样就能统计出字符串中空格的总数，并可以由此
计算出替换之后的字符串的总长度。每替换一个空格，长度增加 2，因此替换以后字符串的长度等于原来的长度加上 2 乘以空格数目。

我们从字符串的后面开始复制和替换。首先准备两个指针：P1 和 P2。P1 指向
原始字符串的末尾，而 P2 指向替换之后的字符串的末尾。接下来我们向前移动指针 P1，逐个把它指向的字符复制到 P2 指向的位置，直到碰到第一个空格为止。碰到第一个空格之后，把 P1 向前移动 1 个，在 P2 之前插入字符串“%20”。由于 “%20” 的长度为 3，同时也要把 P2 向前移动 3 格。

```cpp
void replace(char str[]) {
	int length = strlen(str), cnt = 0;
	// 统计字符串中的空格数
	for (int i = 0; i < length; ++i)
		cnt += (str[i] == ' ');
	
	int index1 = length - 1;			// 指向字符串原末尾
	int index2 = length + 2 * cnt - 1;	// 指向字符串新末尾
	str[index2 + 1] = '\0';
	
	for (int i = index1; i >= 0; --i) {	// 替换
		if (str[i] == ' ') {
			str[index2--] = '0';
			str[index2--] = '2';
			str[index2--] = '%';
		}
		else
			str[index2--] = str[i];
	}
}
```